#
# Error message definitions for TypeChecker.
#

access.check=\
	Cannot access non-public type: {0}

template.name=\
	Template name must exactly match file name ''{0}'', ignoring ''.tea'' extension.  Templates calling this template must also exactly match this name and are case sensitive.

typename.unknown=\
	Type ''{0}'' is unknown
typename.package.conflict=\
	Type ''{0}'' is located in packages ''{1}'' and ''{2}'', use the fully qualified name to disambiguate

variable.declared=\
	Variable ''{0}'' already declared
variable.declared.here=\
	Variable ''{0}'' declared here
variable.not.declared=\
    Variable ''{0}'' not declared
variable.undefined=\
	Internal error: variable ''{0}'' undefined
variable.primitive.uninitialized=\
        A declared primitive ''{0}'' must be set to an initial value

assignmentstatement.cast.invalid=\
        Cannot convert an ''{0}'' to a ''{1}''

foreach.iteration.not.supported=\
	Foreach can''t loop through type ''{0}''
foreach.reverse.not.supported=\
	Reverse looping not supported for type ''{0}''
foreach.range.start=\
	Start of range must be a number, not a ''{0}''
foreach.range.end=\
	End of range must be a number, not a ''{0}''
foreach.loopvar.noreuse=\
	Loop variable ''{0}'' cannot be reused in another loop
foreach.loopvar.nomodify=\
	Loop variable ''{0}'' cannot be modified
foreach.as.collection.required=\
        The ''as'' reserved word can only be used with collections/arrays
foreach.as.not.assignable=\
        The loop variable type ''{0}'' must be a subclass of ''{1}'' (or vice versa)

break.not.inside.foreach=\
	Break must be inside a foreach loop
break.code.unreachable=\
	Code is unreachable

continue.not.inside.foreach=\
	Continue must be inside a foreach loop

if.condition=\
	If statement condition must be of type boolean

substitution.undeclared=\
	Undeclared substitution not allowed

expressionstatement.receiver=\
	No suitable receiver for type ''{0}''

returnstatement.type=\
	Return type of ''{0}'' is not compatible with other return type of ''{1}''

newarrayexpression.associative=\
	Associative array must have an even number of elements

functioncallexpression.function.void=\
	Function does not return a value
if.condition=\
	If statement condition must be of type boolean

substitution.undeclared=\
	Undeclared substitution not allowed

expressionstatement.receiver=\
	No suitable receiver for type ''{0}''

returnstatement.type=\
	Return type of ''{0}'' is not compatible with other return type of ''{1}''

newarrayexpression.associative=\
	Associative array must have an even number of elements

functioncallexpression.function.void=\
	Function does not return a value
functioncallexpression.not.found=\
	Can't find function
functioncallexpression.ambiguous=\
	Function call is ambiguous
	
templatecallexpression.parameter.count=\
	Template called with wrong number of parameters: expecting {0}, not {1}
templatecallexpression.substitution.no=\
	Substitution block cannot be passed to template ''{0}''
templatecallexpression.substitution.yes=\
	Substitution block must be passed to template ''{0}''
templatecallexpression.parameter.unknown=\
	Unknown formal parameter type in called template
templatecallexpression.conversion=\
	Cannot convert actual type of ''{0}'' to formal type of ''{1}''
templatecallexpression.template.void=\
	Template call does not return a value
templatecallexpression.not.found=\
	Can't find template or case sensitivity mismatch.

variableref.undefined=\
	Variable ''{0}'' undefined

lookup.undefined=\
	Property ''{0}'' not defined for type ''{1}''
lookup.array.only=\
	Non-array access to property ''{0}'' not allowed
lookup.unreadable=\
	Property ''{0}'' cannot be read

arraylookup.unsupported=\
	Array lookup not supported for type ''{0}''
arraylookup.unsupported.for=\
	Array lookup not supported for type ''{0}'' with type ''{1}''

negateexpression.type=\
	Negate operation only works with numbers

notexpression.type=\
	Not operation only works with booleans

binaryexpression.type.left=\
	Left side of ''{0}'' expression must be of type ''{1}''
binaryexpression.type.right=\
	Right side of ''{0}'' expression must be of type ''{1}''
binaryexpression.type.both=\
	Both sides of ''{0}'' expression must be of type ''{1}''

relationalexpression.type.mismatch=\
	The ''{0}'' operator cannot compare a ''{1}'' to a ''{2}''
relationalexpression.isa.left=\
	Left side of ''{0}'' operation must be a simple variable reference
relationalexpression.isa.impossible=\
	Impossible for ''{0}'' to be a ''{1}''
